<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TD2 — Exo 1 Three.js (capteurs + GLTF + particules)</title>
  <style>
    html,body{height:100%;margin:0}
    body{font-family:system-ui,Arial,sans-serif;background:#0f1116;color:#e5e7eb}
    #ui{position:fixed;inset:12px auto auto 12px;z-index:10;display:flex;gap:8px;flex-wrap:wrap}
    #ui button{padding:8px 12px;border-radius:8px;border:1px solid #444;background:#1f2937;color:#fff;cursor:pointer}
    #log{position:fixed;right:12px;top:12px;background:#111827cc;padding:8px 12px;border-radius:8px;font-size:12px}
    canvas{display:block}
  </style>

  <!-- Import map pour résoudre "three" et ses addons -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="ui">
  <button id="btnStartSensors">Activer capteurs (iOS/Android)</button>
  <button id="btnCalib">Calibrer</button>
  <button id="btnControlCar">Contrôler la voiture : ON</button>
  <button id="btnToggleRain">Pluie : OFF</button>
</div>
<div id="log">α: — β: — γ: — | ax: — ay: — az: —</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

// --------- Config ---------
const MODEL_FILE = './assets/models/porsche.glb'; // adapte si besoin

// --------- Scène de base ---------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1116);
scene.fog = new THREE.Fog(0x0f1116, 30, 120);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
camera.position.set(8, 5, 14);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Lumières
const ambient = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambient);
const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.5);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(10, 15, 8);
dir.castShadow = true;
dir.target.position.set(0, -1, 0);
scene.add(dir.target);
scene.add(dir);
dir.shadow.mapSize.set(2048, 2048);
dir.shadow.camera.near = 0.5;
dir.shadow.camera.far  = 60;
dir.shadow.camera.left   = -20;
dir.shadow.camera.right  =  20;
dir.shadow.camera.top    =  20;
dir.shadow.camera.bottom = -20;
dir.shadow.bias = -0.0003;
dir.shadow.normalBias = 0.02;

// Sol (y = -1)
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(200, 200),
  new THREE.MeshStandardMaterial({ color:0x1c2431, roughness:0.9, metalness:0.0 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y = -1;
ground.receiveShadow = true;
scene.add(ground);

// --------- Cube (immobile sauf capteurs) ---------
const tex = new THREE.TextureLoader().load('./assets/textures/checker.png');
tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(2,2);
const cubeMat = new THREE.MeshStandardMaterial({ map: tex, roughness:0.5, metalness:0.1 });

const cubeSize = 1.6;
const cube = new THREE.Mesh(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize), cubeMat);
cube.castShadow = cube.receiveShadow = true;
// position fixe en hauteur, à droite
const cubeBase = new THREE.Vector3(1.5, 2.6, 0);
cube.position.copy(cubeBase);
scene.add(cube);

// --------- Helper placement modèle au sol ---------
function centerScalePlaceOnGround(object3D, targetMaxDim = 5) {
  const box = new THREE.Box3().setFromObject(object3D);
  const size = new THREE.Vector3(); box.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z) || 1;
  object3D.scale.setScalar(targetMaxDim / maxDim);

  const box2 = new THREE.Box3().setFromObject(object3D);
  const center2 = new THREE.Vector3(); box2.getCenter(center2);
  const dy = (-1) - box2.min.y; // poser au sol
  object3D.position.add(new THREE.Vector3(-center2.x, dy, -center2.z));
}

// --------- Modèle GLTF (Porsche) via un groupe wrapper ---------
let carGroup = null;
let carBase = null;

new GLTFLoader().load(MODEL_FILE, (gltf)=>{
  const model = gltf.scene;

  // Tout vert clair ? décommente si voulu
  // const greenMat = new THREE.MeshStandardMaterial({ color: 0x90EE90, metalness:0.2, roughness:0.4 });
  // model.traverse(n => { if (n.isMesh) n.material = greenMat; });

  model.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; }});
  centerScalePlaceOnGround(model, 5);

  // Crée un wrapper pour animer facilement la voiture
  carGroup = new THREE.Group();
  // Place le groupe près du cube (à gauche)
  carGroup.position.set(-1.5, -1, 0); // y=-1 = sol
  carGroup.add(model);
  // Replace le modèle au centre du groupe
  model.position.set(0, 0, 0);
  model.rotation.set(0, 0, 0);

  scene.add(carGroup);
  carBase = carGroup.position.clone();
}, undefined, (e)=>console.warn('GLTF non chargé:', e));

// --------- Pluie (points) ---------
let rainPoints = null, rainEnabled = false;
(function buildRain(){
  const COUNT = 1200;
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(COUNT*3);
  for (let i=0;i<COUNT;i++){
    pos[3*i+0] = (Math.random()-0.5)*80;
    pos[3*i+1] = Math.random()*60 + 5;
    pos[3*i+2] = (Math.random()-0.5)*80;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const pmat = new THREE.PointsMaterial({ size:0.08 });
  rainPoints = new THREE.Points(geo, pmat);
  scene.add(rainPoints);
})();

// --------- Contrôles & UI ---------
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const btnRain = document.getElementById('btnToggleRain');
btnRain.onclick = ()=>{ rainEnabled = !rainEnabled; btnRain.textContent = `Pluie : ${rainEnabled?'ON':'OFF'}`; };

let controlCar = true;
const btnCar = document.getElementById('btnControlCar');
btnCar.onclick = ()=>{ controlCar = !controlCar; btnCar.textContent = `Contrôler la voiture : ${controlCar?'ON':'OFF'}`; };

// --------- Capteurs, lissage & calibrage ---------
let alpha=0, beta=0, gamma=0, ax=0, ay=0, az=0;
let sensorsActive = false;

const calib = { beta:0, gamma:0 };         // offset neutre
const smooth = { beta:0, gamma:0 };        // valeurs lissées (radians)
const SMOOTH = 0.15;

document.getElementById('btnStartSensors').onclick = requestSensors;
document.getElementById('btnCalib').onclick = ()=>{ calib.beta = beta; calib.gamma = gamma; };

function requestSensors(){
  const needPerm = typeof(DeviceOrientationEvent) !== 'undefined'
    && typeof DeviceOrientationEvent.requestPermission === 'function';
  if (needPerm){
    DeviceOrientationEvent.requestPermission().then(state=>{
      if (state === 'granted'){ attachSensors(); sensorsActive = true; }
      else alert('Permission capteurs refusée.');
    }).catch(console.warn);
  } else { attachSensors(); sensorsActive = true; }
}
function attachSensors(){
  addEventListener('deviceorientation', (e)=>{ alpha=e.alpha??0; beta=e.beta??0; gamma=e.gamma??0; }, true);
  addEventListener('devicemotion', (e)=>{
    ax = e.accelerationIncludingGravity?.x ?? 0;
    ay = e.accelerationIncludingGravity?.y ?? 0;
    az = e.accelerationIncludingGravity?.z ?? 0;
  }, true);
}

const logEl = document.getElementById('log');
function updateLog(){
  logEl.textContent = `α:${alpha.toFixed(0)} β:${beta.toFixed(0)} γ:${gamma.toFixed(0)} | ax:${ax.toFixed(1)} ay:${ay.toFixed(1)} az:${az.toFixed(1)}`;
}

// --------- Resize ---------
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// --------- Animation ---------
renderer.setAnimationLoop(()=>{
  // Convertit (β,γ) en radians après calibrage, puis lissage
  const b = THREE.MathUtils.degToRad(beta - calib.beta);
  const g = THREE.MathUtils.degToRad(gamma - calib.gamma);
  smooth.beta = THREE.MathUtils.lerp(smooth.beta, b, SMOOTH);
  smooth.gamma= THREE.MathUtils.lerp(smooth.gamma,g, SMOOTH);

  // Cube : contrôle uniquement via capteurs (aucune auto-rotation ni "hover")
  cube.rotation.x = smooth.beta * 0.7;
  cube.rotation.y = smooth.gamma* 0.7;
  cube.position.copy(cubeBase);

  // Voiture : rotation + léger décalage latéral via capteurs
  if (carGroup){
    if (controlCar && sensorsActive){
      carGroup.rotation.set(smooth.beta * 0.3, smooth.gamma * 1.0, 0); // pitch léger, yaw clair
      const dx = THREE.MathUtils.clamp(smooth.gamma * 1.2, -0.6, 0.6);
      carGroup.position.set(carBase.x + dx, carBase.y, carBase.z);
    }
  }

  // Pluie
  if (rainPoints && rainEnabled){
    const pos = rainPoints.geometry.attributes.position;
    for (let i=0;i<pos.count;i++){
      let y = pos.getY(i) - (0.15 + Math.random()*0.15);
      if (y < 0) y = 60;
      pos.setY(i, y);
    }
    pos.needsUpdate = true;
  }

  controls.update();
  updateLog();
  renderer.render(scene, camera);
});
</script>
</body>
</html>
